{"version":3,"file":"index.cjs","sources":["../src/index.ts"],"sourcesContent":["const controlChar = \"^\";\n\nconst codepages = {\n  /** Default codepage */\n  \"8\": \"CP1252\",\n\n  /** Latin 1 */\n  L: \"CP1252\",\n\n  /** Greek */\n  G: \"CP1253\",\n\n  /** Cyrillic */\n  C: \"CP1251\",\n\n  /** Central Europe */\n  E: \"CP1250\",\n\n  /** Turkish */\n  T: \"CP1254\",\n\n  /** Baltic */\n  B: \"CP1257\",\n\n  /** Japanese */\n  J: \"shift-jis\",\n\n  /** Traditional Chinese */\n  H: \"big5\",\n\n  /** Simplified Chinese */\n  S: \"gbk\",\n\n  /** Korean */\n  K: \"euc-kr\",\n} as const;\n\ntype Codepage = keyof typeof codepages;\n\nconst specials: Record<string, string> = {\n  v: \"|\",\n  a: \"*\",\n  c: \":\",\n  d: \"\\\\\",\n  s: \"/\",\n  q: \"?\",\n  t: '\"',\n  l: \"<\",\n  r: \">\",\n  h: \"#\",\n  \"^\": \"^^\",\n};\n\nconst isMultiByte = (codepage: Codepage, character: number): boolean => {\n  switch (codepage) {\n    case \"L\":\n    case \"8\":\n    case \"G\":\n    case \"C\":\n    case \"E\":\n    case \"T\":\n    case \"B\":\n      return false;\n    case \"J\":\n      return (\n        (character > 0x80 && character < 0xa0) ||\n        (character >= 0xe0 && character < 0xfd)\n      );\n    case \"H\":\n    case \"S\":\n    case \"K\":\n      return character > 0x80 && character < 0xff;\n    default:\n      throw new Error(`Unknown Codepage: ${character}`);\n  }\n};\n\nfunction parseLFSMessage(msg: Uint8Array | string): string {\n  const buffer =\n    typeof msg === \"string\"\n      ? new Uint8Array([...msg].map((c) => c.charCodeAt(0)))\n      : msg;\n\n  // Default codepage: Latin 1\n  let currentCodepage: Codepage = \"L\";\n  let resultString = \"\";\n  let blockStart = 0;\n  let blockEnd = 0;\n  let iconvCurrent = new TextDecoder(codepages[currentCodepage]);\n\n  for (let i = 0; i <= buffer.length; i++) {\n    if (i === buffer.length || buffer[i] === 0) {\n      // End of string\n      if (blockStart < blockEnd) {\n        // Convert current block if it has data\n        resultString += iconvCurrent.decode(buffer.slice(blockStart, blockEnd));\n      }\n      i = buffer.length; // Break out of loop\n    } else if (isMultiByte(currentCodepage, buffer[i])) {\n      // Skip multi-byte char\n      blockEnd += 2;\n      i++;\n    } else if (buffer[i] === controlChar.charCodeAt(0)) {\n      // Found '^'\n      let cpCheck = iconvCurrent.decode(buffer.slice(i + 1, i + 2));\n      if (isValidCodepage(cpCheck)) {\n        if (blockStart < blockEnd) {\n          // Convert current block if it has data\n          resultString += iconvCurrent.decode(\n            buffer.slice(blockStart, blockEnd)\n          );\n        }\n        // Changing codepage\n        currentCodepage = cpCheck;\n        iconvCurrent = new TextDecoder(codepages[currentCodepage]);\n\n        // Start a new block\n        if (buffer[i + 1] === 0x38) {\n          blockStart = i;\n        } else {\n          blockStart = i + 2;\n        }\n        blockEnd = i + 2;\n        i++;\n      } else if (specials.hasOwnProperty(cpCheck)) {\n        resultString += specials[cpCheck];\n\n        // Start a new block\n        if (buffer[i + 1] === 0x38) {\n          blockStart = i;\n        } else {\n          blockStart = i + 2;\n        }\n        blockEnd = i + 2;\n\n        i++;\n      } else {\n        // Skip escaped/colour change character\n        blockEnd += 2;\n        i++;\n      }\n    } else {\n      // single byte char\n      blockEnd++;\n    }\n  }\n\n  return resultString;\n}\n\nfunction isValidCodepage(codepage: string): codepage is Codepage {\n  return codepages.hasOwnProperty(codepage);\n}\n\nexport default parseLFSMessage;\n"],"names":["codepages","L","G","C","E","T","B","J","H","S","K","specials","v","a","c","d","s","q","t","l","r","h","isMultiByte","codepage","character","Error","msg","buffer","Uint8Array","map","charCodeAt","currentCodepage","resultString","blockStart","blockEnd","iconvCurrent","TextDecoder","i","length","decode","slice","cpCheck","hasOwnProperty"],"mappings":"AAAA,IAEMA,EAAY,CAEhB,EAAK,SAGLC,EAAG,SAGHC,EAAG,SAGHC,EAAG,SAGHC,EAAG,SAGHC,EAAG,SAGHC,EAAG,SAGHC,EAAG,YAGHC,EAAG,OAGHC,EAAG,MAGHC,EAAG,UAKCC,EAAmC,CACvCC,EAAG,IACHC,EAAG,IACHC,EAAG,IACHC,EAAG,KACHC,EAAG,IACHC,EAAG,IACHC,EAAG,IACHC,EAAG,IACHC,EAAG,IACHC,EAAG,IACH,IAAK,MAGUC,EAAG,SAACC,EAAoBC,GACvC,OAAQD,GACN,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACH,OAAO,EACT,IAAK,IACH,OACGC,EAAY,KAAQA,EAAY,KAChCA,GAAa,KAAQA,EAAY,IAEtC,IAAK,IACL,IAAK,IACL,IAAK,IACH,OAAgBA,EAAG,KAAQA,EAAY,IACzC,QACE,MAAM,IAASC,MAAA,qBAAsBD,GAE3C,iBAEA,SAAyBE,GAavB,IAZA,IAAYC,EACK,iBAARD,EACH,IAAcE,WAAC,GAAIF,OAAAA,GAAKG,IAAI,SAACf,GAAC,OAAMA,EAACgB,WAAW,EAAE,IAClDJ,EAGaK,EAAa,IAChBC,EAAG,GACfC,EAAa,EACLC,EAAG,EACCC,EAAG,IAAIC,YAAYpC,EAAU+B,IAEpCM,EAAI,EAAGA,GAAKV,EAAOW,OAAQD,IAClC,GAAIA,IAAMV,EAAOW,QAAwB,IAAdX,EAAOU,GAE5BJ,EAAaC,IAEfF,GAAgBG,EAAaI,OAAOZ,EAAOa,MAAMP,EAAYC,KAE/DG,EAAIV,EAAOW,YACFhB,GAAAA,EAAYS,EAAiBJ,EAAOU,IAE7CH,GAAY,EACZG,SACK,GAAIV,EAAOU,KAtGF,IAsGqBP,WAAW,GAAI,CAElD,IAAWW,EAAGN,EAAaI,OAAOZ,EAAOa,MAAMH,EAAI,EAAGA,EAAI,IA+CvDrC,EAAU0C,eA9COD,IACdR,EAAaC,IAEfF,GAAgBG,EAAaI,OAC3BZ,EAAOa,MAAMP,EAAYC,KAI7BH,EAAkBU,EAClBN,EAAe,IAAIC,YAAYpC,EAAU+B,IAIvCE,EADoB,KAAlBN,EAAOU,EAAI,GACAA,EAEAA,EAAI,EAEnBH,EAAWG,EAAI,EACfA,KACS1B,EAAS+B,eAAeD,IACjCT,GAAgBrB,EAAS8B,GAIvBR,EADoB,KAAlBN,EAAOU,EAAI,GACAA,EAEAA,EAAI,EAEnBH,EAAWG,EAAI,EAEfA,MAGAH,GAAY,EACZG,IAEH,MAECH,IAIJ,OACFF,CAAA"}